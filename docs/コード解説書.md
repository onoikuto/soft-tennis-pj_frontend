# VALVE アプリ コード解説書

このドキュメントは、VALVEアプリ（ソフトテニススコア管理アプリ）のコードを理解するための学習資料です。

---

## 目次

1. [プロジェクト構成](#1-プロジェクト構成)
2. [Flutterの基本概念](#2-flutterの基本概念)
3. [エントリーポイント（main.dart）](#3-エントリーポイントmaindart)
4. [データモデル（models/）](#4-データモデルmodels)
5. [データベース（database/）](#5-データベースdatabase)
6. [画面（screens/）](#6-画面screens)
7. [ウィジェット（widgets/）](#7-ウィジェットwidgets)
8. [サービス（services/）](#8-サービスservices)
9. [状態管理のパターン](#9-状態管理のパターン)
10. [よく使うFlutterパターン](#10-よく使うflutterパターン)

---

## 1. プロジェクト構成

```
lib/
├── main.dart              # アプリのエントリーポイント
├── constants/             # 定数（色、テキストスタイル）
│   ├── app_colors.dart
│   └── app_text_styles.dart
├── database/              # データベース関連
│   └── database_helper.dart
├── models/                # データモデル（データの構造を定義）
│   ├── match.dart
│   ├── game_score.dart
│   ├── set_score.dart
│   └── point_detail.dart
├── screens/               # 画面（ページ）
│   ├── main_menu_screen.dart
│   ├── match_setup_screen.dart
│   ├── official_scoring_screen.dart
│   ├── statistics_screen.dart
│   └── ... その他の画面
├── services/              # ビジネスロジック
│   └── subscription_service.dart
└── widgets/               # 再利用可能なUI部品
    ├── common/
    │   ├── bottom_navigation_bar.dart
    │   └── simple_button.dart
    └── score_input_dialog.dart
```

### 役割の分離

| フォルダ | 役割 | 例え |
|---------|------|------|
| models/ | データの形を定義 | 「試合データはこういう情報を持つ」 |
| database/ | データの保存・取得 | 「試合データをDBに保存/読み込み」 |
| screens/ | 画面のUI | 「この画面にはこのボタンがある」 |
| widgets/ | 再利用部品 | 「このボタンは色々な画面で使う」 |
| services/ | ビジネスロジック | 「サブスク状態を管理」 |

---

## 2. Flutterの基本概念

### 2.1 Widget（ウィジェット）とは？

Flutterでは、**画面に表示されるものは全てWidget**です。

```dart
// ボタンもWidget
ElevatedButton(
  onPressed: () {},
  child: Text('押してね'),
)

// テキストもWidget
Text('こんにちは')

// コンテナ（箱）もWidget
Container(
  color: Colors.blue,
  child: Text('青い箱'),
)
```

### 2.2 StatelessWidget vs StatefulWidget

#### StatelessWidget（状態を持たない）
一度作ったら変化しないUI。

```dart
class MyText extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Text('変化しないテキスト');
  }
}
```

#### StatefulWidget（状態を持つ）
ユーザー操作などで変化するUI。

```dart
class Counter extends StatefulWidget {
  @override
  State<Counter> createState() => _CounterState();
}

class _CounterState extends State<Counter> {
  int count = 0;  // ← これが「状態」

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('カウント: $count'),
        ElevatedButton(
          onPressed: () {
            setState(() {  // ← 状態を変更して画面を更新
              count++;
            });
          },
          child: Text('増やす'),
        ),
      ],
    );
  }
}
```

**重要ポイント:**
- `setState()` を呼ぶと、`build()` が再実行される
- `build()` が再実行されると、画面が更新される

---

## 3. エントリーポイント（main.dart）

```dart
// main.dart の解説

void main() async {
  // ① Flutterエンジンの初期化（非同期処理を使う前に必要）
  WidgetsFlutterBinding.ensureInitialized();
  
  // ② データベースの初期化
  // Web版とデスクトップ/モバイル版で処理を分ける
  if (kIsWeb) {
    databaseFactory = databaseFactoryFfiWeb;
  } else {
    sqfliteFfiInit();
    databaseFactory = databaseFactoryFfi;
  }
  
  // ③ データベース接続
  await DatabaseHelper.instance.database;
  
  // ④ アプリを起動
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'ソフトテニス採点表',
      theme: ThemeData(...),     // アプリ全体のデザイン設定
      home: const MainMenuScreen(),  // 最初に表示する画面
    );
  }
}
```

### MaterialApp とは？
- アプリの「土台」となるWidget
- テーマ（色やフォント）を設定
- 画面遷移の管理
- `home:` に最初の画面を指定

---

## 4. データモデル（models/）

### 4.1 モデルとは？

「このデータはこういう情報を持つ」を定義したもの。

例：`Match`（試合）モデル

```dart
class Match {
  final int? id;                    // データベースのID
  final String tournamentName;      // 大会名
  final String team1Player1;        // チーム1のプレイヤー1
  final String team1Player2;        // チーム1のプレイヤー2
  final String team1Club;           // チーム1の所属
  // ... 他のフィールド

  // コンストラクタ（オブジェクトを作るときに呼ばれる）
  Match({
    this.id,
    required this.tournamentName,   // required = 必須
    required this.team1Player1,
    // ...
  });
}
```

### 4.2 toMap() と fromMap()

データベースとの変換メソッド。

```dart
// Dartオブジェクト → データベース用Map
Map<String, dynamic> toMap() {
  return {
    'id': id,
    'tournament_name': tournamentName,  // スネークケースに変換
    'team1_player1': team1Player1,
  };
}

// データベースMap → Dartオブジェクト
factory Match.fromMap(Map<String, dynamic> map) {
  return Match(
    id: map['id'] as int?,
    tournamentName: map['tournament_name'] as String,
    team1Player1: map['team1_player1'] as String,
  );
}
```

**なぜ変換が必要？**
- Dart: `team1Player1`（キャメルケース）
- SQLite: `team1_player1`（スネークケース）
- 命名規則が違うので変換が必要

### 4.3 getter（ゲッター）

計算して値を返すプロパティ。

```dart
class Match {
  final String team1Player1;
  final String team1Player2;
  final String team1Club;

  // getter: 呼び出すたびに計算される
  String get team1DisplayName {
    final players = '$team1Player1・$team1Player2';
    return team1Club.isNotEmpty ? '$players ($team1Club)' : players;
  }
}

// 使い方
final match = Match(...);
print(match.team1DisplayName);  // "田中・佐藤 (早稲田大学)"
```

---

## 5. データベース（database/）

### 5.1 シングルトンパターン

アプリ全体で1つだけのインスタンスを共有するパターン。

```dart
class DatabaseHelper {
  // ① 唯一のインスタンスを作成
  static final DatabaseHelper instance = DatabaseHelper._init();
  
  // ② プライベートコンストラクタ（外部からnewできない）
  DatabaseHelper._init();
  
  // ③ データベースのキャッシュ
  static Database? _database;
  
  // ④ データベース取得（なければ初期化）
  Future<Database> get database async {
    if (_database != null) return _database!;  // あればそのまま返す
    _database = await _initDB('soft_tennis.db');  // なければ初期化
    return _database!;
  }
}

// 使い方（どこからでも同じインスタンスにアクセス）
final db = await DatabaseHelper.instance.database;
```

### 5.2 CRUD操作

| 操作 | 意味 | メソッド例 |
|------|------|-----------|
| Create | 作成 | `insertMatch(match)` |
| Read | 読取 | `getMatch(id)`, `getAllMatches()` |
| Update | 更新 | `updateMatch(match)` |
| Delete | 削除 | `deleteMatch(id)` |

```dart
// Create（作成）
Future<int> insertMatch(Match match) async {
  final db = await database;
  return await db.insert('matches', match.toMap());
}

// Read（1件取得）
Future<Match?> getMatch(int id) async {
  final db = await database;
  final maps = await db.query(
    'matches',
    where: 'id = ?',
    whereArgs: [id],
  );
  if (maps.isEmpty) return null;
  return Match.fromMap(maps.first);
}

// Read（全件取得）
Future<List<Match>> getAllMatches() async {
  final db = await database;
  final maps = await db.query('matches', orderBy: 'created_at DESC');
  return maps.map((map) => Match.fromMap(map)).toList();
}

// Update（更新）
Future<int> updateMatch(Match match) async {
  final db = await database;
  return await db.update(
    'matches',
    match.toMap(),
    where: 'id = ?',
    whereArgs: [match.id],
  );
}

// Delete（削除）
Future<int> deleteMatch(int id) async {
  final db = await database;
  return await db.delete(
    'matches',
    where: 'id = ?',
    whereArgs: [id],
  );
}
```

### 5.3 async/await

非同期処理を「同期的に書ける」ようにする仕組み。

```dart
// ❌ コールバック地獄（昔のやり方）
database.query('matches').then((result) {
  // 結果を処理
}).catchError((error) {
  // エラー処理
});

// ✅ async/await（現代的）
Future<void> loadData() async {
  try {
    final result = await database.query('matches');  // 完了まで待つ
    // 結果を処理
  } catch (error) {
    // エラー処理
  }
}
```

**ポイント:**
- `async`: この関数は非同期処理を含むよ
- `await`: この処理が完了するまで待つよ
- `Future<T>`: 将来的にT型の値が返ってくるよ

---

## 6. 画面（screens/）

### 6.1 画面の基本構造

```dart
class SomeScreen extends StatefulWidget {
  @override
  State<SomeScreen> createState() => _SomeScreenState();
}

class _SomeScreenState extends State<SomeScreen> {
  // ① 状態（変数）
  bool _isLoading = true;
  List<Match> _matches = [];

  // ② 初期化（画面表示時に1回だけ実行）
  @override
  void initState() {
    super.initState();
    _loadData();  // データを読み込む
  }

  // ③ データ読み込み
  Future<void> _loadData() async {
    setState(() => _isLoading = true);  // ローディング開始
    
    final matches = await DatabaseHelper.instance.getAllMatches();
    
    setState(() {  // 画面を更新
      _matches = matches;
      _isLoading = false;
    });
  }

  // ④ UI構築
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('タイトル')),
      body: _isLoading 
        ? Center(child: CircularProgressIndicator())  // ローディング中
        : _buildContent(),  // データ表示
    );
  }

  Widget _buildContent() {
    return ListView.builder(
      itemCount: _matches.length,
      itemBuilder: (context, index) {
        return ListTile(title: Text(_matches[index].tournamentName));
      },
    );
  }
}
```

### 6.2 Scaffold（スキャフォールド）

画面の骨組みを提供するWidget。

```dart
Scaffold(
  appBar: AppBar(...),           // 上部のバー
  body: ...,                      // メインコンテンツ
  bottomNavigationBar: ...,       // 下部のナビゲーション
  floatingActionButton: ...,      // 浮いてるボタン
  drawer: ...,                    // サイドメニュー
)
```

### 6.3 画面遷移（Navigator）

```dart
// 次の画面に進む
Navigator.push(
  context,
  MaterialPageRoute(
    builder: (context) => NextScreen(),
  ),
);

// 前の画面に戻る
Navigator.pop(context);

// 戻り値を受け取る
final result = await Navigator.push(
  context,
  MaterialPageRoute(
    builder: (context) => InputScreen(),
  ),
);
if (result != null) {
  // resultを使う
}

// 戻り値を返す（InputScreenで）
Navigator.pop(context, '入力した値');
```

---

## 7. ウィジェット（widgets/）

### 7.1 再利用可能なWidgetを作る

```dart
// widgets/common/simple_button.dart

class SimpleButton extends StatelessWidget {
  final String title;
  final VoidCallback onTap;
  final Color? backgroundColor;

  const SimpleButton({
    required this.title,
    required this.onTap,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: onTap,
      style: ElevatedButton.styleFrom(
        backgroundColor: backgroundColor ?? Colors.blue,
      ),
      child: Text(title),
    );
  }
}

// 使い方
SimpleButton(
  title: '保存',
  onTap: () => _save(),
  backgroundColor: Colors.green,
)
```

### 7.2 レイアウトWidget

```dart
// 縦に並べる
Column(
  children: [
    Text('1行目'),
    Text('2行目'),
    Text('3行目'),
  ],
)

// 横に並べる
Row(
  children: [
    Text('左'),
    Text('中央'),
    Text('右'),
  ],
)

// 余白を追加
Padding(
  padding: EdgeInsets.all(16),
  child: Text('周りに余白'),
)

// サイズを指定
SizedBox(
  width: 100,
  height: 50,
  child: Text('固定サイズ'),
)

// 残りのスペースを埋める
Expanded(
  child: Text('残りを全部使う'),
)
```

---

## 8. サービス（services/）

ビジネスロジック（画面に依存しない処理）をまとめる場所。

```dart
// services/subscription_service.dart

class SubscriptionService {
  static const String _subscriptionKey = 'is_subscribed';
  
  // サブスク状態を取得
  static Future<bool> isSubscribed() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getBool(_subscriptionKey) ?? false;
  }
  
  // サブスク状態を設定
  static Future<void> setSubscribed(bool value) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_subscriptionKey, value);
  }
}

// 使い方（どの画面からでも）
final isSubscribed = await SubscriptionService.isSubscribed();
```

---

## 9. 状態管理のパターン

### 9.1 setState（このアプリで使用）

最もシンプルな方法。1つの画面内での状態管理に適している。

```dart
class _MyScreenState extends State<MyScreen> {
  int _count = 0;

  void _increment() {
    setState(() {
      _count++;  // 状態を変更
    });
    // setStateを呼ぶとbuild()が再実行される
  }

  @override
  Widget build(BuildContext context) {
    return Text('$_count');  // 新しい値で再描画
  }
}
```

### 9.2 コールバックで親に通知

子Widgetから親Widgetに変更を伝える。

```dart
// 親Widget
class ParentWidget extends StatefulWidget {
  @override
  State<ParentWidget> createState() => _ParentWidgetState();
}

class _ParentWidgetState extends State<ParentWidget> {
  String _message = '';

  void _handleChildMessage(String message) {
    setState(() {
      _message = message;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('受信: $_message'),
        ChildWidget(onMessage: _handleChildMessage),  // コールバックを渡す
      ],
    );
  }
}

// 子Widget
class ChildWidget extends StatelessWidget {
  final ValueChanged<String> onMessage;  // コールバック

  const ChildWidget({required this.onMessage});

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: () => onMessage('こんにちは'),  // 親に通知
      child: Text('送信'),
    );
  }
}
```

---

## 10. よく使うFlutterパターン

### 10.1 条件分岐でWidgetを切り替え

```dart
// 三項演算子
_isLoading 
  ? CircularProgressIndicator() 
  : Text('読み込み完了');

// if-else（Columnなどの中で）
Column(
  children: [
    if (_isError) Text('エラー発生'),
    if (!_isError) Text('正常'),
  ],
)

// スプレッド演算子（複数Widgetを条件で追加）
Column(
  children: [
    Text('常に表示'),
    if (_showExtra) ...[
      Text('追加1'),
      Text('追加2'),
    ],
  ],
)
```

### 10.2 リストの表示

```dart
// ListView.builder（大量データ向け、効率的）
ListView.builder(
  itemCount: items.length,
  itemBuilder: (context, index) {
    return ListTile(title: Text(items[index]));
  },
)

// map（少量データ向け）
Column(
  children: items.map((item) => Text(item)).toList(),
)
```

### 10.3 ダイアログ

```dart
// 表示
showDialog(
  context: context,
  builder: (context) => AlertDialog(
    title: Text('確認'),
    content: Text('削除しますか？'),
    actions: [
      TextButton(
        onPressed: () => Navigator.pop(context, false),
        child: Text('キャンセル'),
      ),
      TextButton(
        onPressed: () => Navigator.pop(context, true),
        child: Text('削除'),
      ),
    ],
  ),
);

// 結果を受け取る
final result = await showDialog<bool>(...);
if (result == true) {
  // 削除処理
}
```

### 10.4 スナックバー（一時的なメッセージ）

```dart
ScaffoldMessenger.of(context).showSnackBar(
  SnackBar(
    content: Text('保存しました'),
    duration: Duration(seconds: 2),
    action: SnackBarAction(
      label: '取消',
      onPressed: () => _undo(),
    ),
  ),
);
```

### 10.5 フォームとバリデーション

```dart
class _MyFormState extends State<MyForm> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();

  @override
  void dispose() {
    _nameController.dispose();  // メモリリーク防止
    super.dispose();
  }

  void _submit() {
    if (_formKey.currentState!.validate()) {  // バリデーション実行
      // 送信処理
    }
  }

  @override
  Widget build(BuildContext context) {
    return Form(
      key: _formKey,
      child: Column(
        children: [
          TextFormField(
            controller: _nameController,
            validator: (value) {
              if (value == null || value.isEmpty) {
                return '名前を入力してください';  // エラーメッセージ
              }
              return null;  // OK
            },
          ),
          ElevatedButton(
            onPressed: _submit,
            child: Text('送信'),
          ),
        ],
      ),
    );
  }
}
```

---

## 次のステップ

1. **実際にコードを読む**: `lib/screens/official_scoring_screen.dart` が一番複雑で勉強になります
2. **小さな変更を試す**: ボタンの色を変えるなど、簡単な変更から始める
3. **公式ドキュメント**: https://docs.flutter.dev/
4. **Flutter公式チュートリアル**: https://docs.flutter.dev/get-started/codelab

質問があればいつでも聞いてください！
